<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Eden&#39;s blog</title>
  <subtitle></subtitle>
  <link href="https://eden.is-a.dev/feed.xml" rel="self"/>
  <link href="https://eden.is-a.dev/"/>
  
    <updated>2025-01-05T00:00:00+00:00</updated>
  
  <id>https://eden.is-a.dev</id>
  <author>
    <name>Eden</name>
    <email>lsahlm1eden@gmail.com</email>
  </author>
  
    
    <entry>
      <title>Worm, a new floating window manager written in Rust</title>
      <link href="https://eden.is-a.dev/posts/Worm-a-new-floating-window-manager-written-in-Rust/"/>
      <updated>2021-10-30T00:00:00+00:00</updated>
      <id>https://eden.is-a.dev/posts/Worm-a-new-floating-window-manager-written-in-Rust/</id>
      <content type="html">
        <![CDATA[
      <h2>Introduction</h2>
<p><a href="https://github.com/codic12/worm">Worm</a> is a brand new floating window manager
for X11 written in Rust by <a href="https://github.com/codic12">codic12</a>.</p>
<p>It's still in an early testing stage, but it's an intriguing wm afterall. While
worm is currently a floating window manager, it's planned to gain tiling
ability. Worm uses tags instead of workspaces, which is a concept borrowed from
DWM. A tag can contain different windows, and a window can belong to different
tags. However, currently worm does not support having more than one tag on
a window or viewing more than on tag at a time.</p>
<!-- more -->
<h2>Installation</h2>
<h3>Build from source</h3>
<pre class="language-bash"><code class="language-bash"><span class="token comment"># Build with cargo git clone https://github.com/codic12/worm cd worm</span><br>cargo build --release<br><br><span class="token comment"># After building, copy the binary files to your PATH</span><br><span class="token function">sudo</span> <span class="token function">cp</span> target/release/<span class="token punctuation">{</span>worm,wormc<span class="token punctuation">}</span> /usr/bin/<br><br><span class="token comment"># If you are using a display manager, copy the desktop entry file to the</span><br>xsessions directory <br><span class="token function">sudo</span> <span class="token function">cp</span> assets/worm.desktop /usr/share/xsessions/</code></pre>
<h3>Use AUR package</h3>
<pre><code>yay -S worm-git
</code></pre>
<h2>Configuration</h2>
<h3>Autostart</h3>
<p>Worm will execute the file '.config/worm/autostart' on startup, which is
supposed to be an executable shell script. An example is
<a href="https://github.com/EdenQwQ/WormConfig/blob/main/autostart">here</a>.</p>
<h3>Hotkey</h3>
<p>Since worm does not have a build-in keyboard mapper, a hotkey daemon like
<a href="https://github.com/baskerville/sxhkd">sxhkd</a> is needed. An example sxhkdrc
is <a href="https://github.com/EdenQwQ/WormConfig/blob/main/sxhkdrc">here</a>.</p>

    ]]>
      </content>
    </entry>
  
    
    <entry>
      <title>First post</title>
      <link href="https://eden.is-a.dev/posts/first_post/"/>
      <updated>2021-10-30T00:00:00+00:00</updated>
      <id>https://eden.is-a.dev/posts/first_post/</id>
      <content type="html">
        <![CDATA[
      <h1>First post from Eden</h1>
<p>I'm a Chinese student who is instereted in tech stuff.</p>
<p><a href="https://github.com/EdenQwQ">Check my github page here</a></p>

    ]]>
      </content>
    </entry>
  
    
    <entry>
      <title>Switching to fish shell</title>
      <link href="https://eden.is-a.dev/posts/Switching-to-fish-shell/"/>
      <updated>2021-11-13T00:00:00+00:00</updated>
      <id>https://eden.is-a.dev/posts/Switching-to-fish-shell/</id>
      <content type="html">
        <![CDATA[
      <p>A philosopher named Luke Smith once said,</p>
<blockquote>
<p>Setting fish as your default shell is like setting python as your default shell.</p>
</blockquote>
<p>So.. Why not? Let's try fish.</p>
<!-- more -->
<p>There are many reasons I can think of for giving fish a try:</p>
<ul>
<li>
<p>Fish loads faster compared to zsh with oh-my-zsh</p>
</li>
<li>
<p>Fish has many built-in functions while zsh needs extensions to use the same
functions</p>
</li>
<li>
<p>Fish is way more user-friendly with its simple syntax and web based
configuration</p>
</li>
</ul>
<p>The web based configuration is too easy to be explained here, so let's talk
about something else that might be helpful.</p>
<h3>1. vimode</h3>
<p>Fish has built-in vimode that allows you to edit the command input with vi
keybindings. To enable vimode, simply run <code>fish_vi_key_bindings</code> in
fish. 'Normally' we are in insert mode, and press ESC to enter 'normal' mode,
just as expected XD.</p>
<h3>2. pywal support</h3>
<p>Fish do not have a built-in pywal support and pywal do not have a official fish
support :). But with pywal's <strong>template</strong> feature, it's not hard to achieve
this.</p>
<p>Check <a href="https://github.com/dylanaraps/pywal/issues/384#issuecomment-505801129">this
comment</a>
under a pywal issue.</p>
<pre class="language-bash"><code class="language-bash"><span class="token function">vim</span> ~/.config/wal/templates/colors.fish</code></pre>
<p>Add lines in the file that look like <code>set fish_color_normal
{foreground.strip}</code>. Source the output file in your config.fish.</p>
<pre class="language-bash"><code class="language-bash"><span class="token builtin class-name">source</span> ~/.cache/wal/colors.fish</code></pre>

    ]]>
      </content>
    </entry>
  
    
    <entry>
      <title>Simple Cellcular Automata written in Python and Rust</title>
      <link href="https://eden.is-a.dev/posts/Simple-Cellcular-Automata-written-in-Python-and-Rust/"/>
      <updated>2022-01-28T00:00:00+00:00</updated>
      <id>https://eden.is-a.dev/posts/Simple-Cellcular-Automata-written-in-Python-and-Rust/</id>
      <content type="html">
        <![CDATA[
      <h2>Brief Introduction</h2>
<p>Cellcular Automata (CA) is a discrete model of computation. In this post, I'll talk about a simple kind of CA called Elementary CA.</p>
<!-- more -->
<h2>What is Elementary CA</h2>
<p>Elementary CA is one-dimensional, which means at any time, the CA is a single line. Each cell has two possible states: 0 or 1. When the cells evolve with time, there is one rule to determine the state of a cell in the next generation depending only on the current state of the cell itself and its two immediate neighbors.</p>
<p>There are 8 = 23 possible configurations for a cell and its two immediate neighbors. The rule defining the cellular automaton must specify the resulting state for each of these possibilities so there are 256 = 223 possible elementary cellular automata.</p>
<p>To gain a clearer knowledge about Elementary CA, please check <a href="https://en.wikipedia.org/wiki/Elementary_cellular_automaton">its wikipedia page</a>.</p>
<h2>How I write Elementary CA</h2>
<p>I'm learning Python and Rust, so I tried to write codes to generate Elementary CA with them.</p>
<p>Check out my source code here: <a href="https://github.com/EdenQwQ/ca">Python</a> <a href="https://github.com/EdenQwQ/ca_rust">Rust</a>
I'll use the Python one as an example.</p>
<h3>Generating random initial cells</h3>
<p>I defined the 'random_bin' function, which can generate a random binary string in a given length. We use string here to allow '0' in the beginning.</p>
<h3>Reflection</h3>
<p>Check out the 'next' function. It receives the current cell string, the number of each cell's neighbors( in the case of Elementary CA, it's 1 ) and the rule. The inner for loop is used to check the state of the cell and its neighbors. We get the state and check the rule for the next state of each cell with the outer for loop.</p>
<h3>Evolve</h3>
<p>The 'evolve' function receives an initial cell string, the number of each cell's neighbors, the rule and evolve times.</p>
<p>It calls the 'next' function to generate the next cell string and loop for the given times.</p>
<h3>Print the evolution</h3>
<p>You can manually set the neighbors number, the length, the evolve times and the rules. Then, run the 'evolve' function which outputs a list containing every cell strings at each times. It's OK to simply print the whole list or each items in it. However, to make the output more readable, you can replace '1' with something like a color block and '0' with an empty space.</p>

    ]]>
      </content>
    </entry>
  
    
    <entry>
      <title>我与Gentoo——为什么Gentoo如此吸引Linux爱好者</title>
      <link href="https://eden.is-a.dev/posts/Why-gentoo-so-popular/"/>
      <updated>2023-07-17T00:00:00+00:00</updated>
      <id>https://eden.is-a.dev/posts/Why-gentoo-so-popular/</id>
      <content type="html">
        <![CDATA[
      <blockquote>
<p>&lt;@insomnia&gt; it only takes three commands to install Gentoo</p>
<p>&lt;@insomnia&gt; <code>cfdisk /dev/hda &amp;&amp; mkfs.xfs /dev/hda1 &amp;&amp; mount /dev/hda1 /mnt/gentoo/ &amp;&amp; chroot /mnt/gentoo/ &amp;&amp; env-update &amp;&amp; . /etc/profile &amp;&amp; emerge sync &amp;&amp; cd /usr/portage &amp;&amp; scripts/bootsrap.sh &amp;&amp; emerge system &amp;&amp; emerge vim &amp;&amp; vi /etc/fstab &amp;&amp; emerge gentoo-dev-sources &amp;&amp; cd /usr/src/linux &amp;&amp; make menuconfig &amp;&amp; make install modules_install &amp;&amp; emerge gnome mozilla-firefox openoffice &amp;&amp; emerge grub &amp;&amp; cp /boot/grub/grub.conf.sample /boot/grub/grub.conf &amp;&amp; vi /boot/grub/grub.conf &amp;&amp; grub &amp;&amp; init 6</code></p>
<p>&lt;@insomnia&gt; that’s the first one</p>
</blockquote>
<!-- more -->
<p>如果你装过Gentoo，你肯定会马上看出来引文中的命令是<strong>不太对</strong>的。
而且当你看到<code>/usr/src/linux</code>以及<code>emerge gnome mozilla-firefox openoffice</code>，你就会知道如果这个命令真的能跑的话，它能跑多久（一整天？难说……）。</p>
<p>Gentoo在Linux及自由软件爱好者群体中已经成为了一个梗，而Gentoo的meme化很大程度上是因为Gentoo闻名遐迩（<s>臭名昭著</s>）的安装之<strong>困难和费时</strong>。</p>
<p><img src="/images/3a4yepx08v4b1.jpg" alt="random gentoo meme">
<em>才4小时？</em></p>
<h2>我与Gentoo</h2>
<p>我最开始接触到Gentoo，是通过distrowatch.com上的随机distro随机到的。
简单浏览了Gentoo的官网后，我得出了一个结论：<strong>为时过早</strong>。
当年的我还是一个安于使用Ubuntu-based distro的单纯孩子，哪里受得了Gentoo官网的冲击（<s>它甚至没有放截图！</s>）。</p>
<p>然而，随着我对Linux的了解逐渐深入，我愈发意识到自己对Gentoo<strong>耿耿于怀</strong>。
终于我在某个无聊的周末尝试装了Gentoo。
当时并没有直接按照amd64 handbook来，而是照着<a href="https://www.youtube.com/watch?v=J7W9MItUSGw">这个视频</a>来。
由于使用了现有的已经配置好的系统，在配置网络和分配硬盘上节省了很多时间。
做好准备后就跟着handbook一步步来，最后还尝试了编译内核，总共也就用了6小时吧……</p>
<p>初次安装后没过几天，我就由于难以忍受各种问题而卸掉了Gentoo。
初次使用Gentoo的经历并不是很愉快，然而这并没有打消我<strong>日用Gentoo的“梦想”</strong>。</p>
<p>接下来的很长一段时间，我都对Gentoo怀有<strong>极其强烈的兴趣</strong>，并在自己没有日用Gentoo的经验的情况下疯狂向别人安利Gentoo。
终于在这个暑假，我又<s>因为过于无聊而</s>手痒了，再次打开Gentoo amd64 handbook，开始安装这个我<strong>梦想中的distro</strong>。
这次我已经熟门熟路（<s>然而还是跳过了编译内核选择了kernel-bin</s>），竟然在两小时内就完成了安装。
现在是我将Gentoo作为主系统日用的第五天，我已经深深爱上了这个<strong>特别而奇妙</strong>的发行版。</p>
<p><img src="/images/9zkccddff81b1.png" alt="gentoo rui">
<em>随处可见的Gentoo</em></p>
<h2>Why Gentoo？</h2>
<p>所以为什么我会对Gentoo这么感兴趣呢？或者说，为什么Gentoo如此吸引Linux爱好者呢？
我想这可以从很多层面展开讨论。</p>
<h3>Philosophy</h3>
<blockquote>
<p>Our tools should be a joy to use, and should help the user to appreciate the richness of the Linux and free software community, and the <strong>flexibility</strong> of free software. This is only possible when the tool is designed to <strong>reflect and transmit the will of the user</strong>, and leave the possibilities open as to the final form of the raw materials (the source code.) If the tool forces the user to do things a particular way, then the tool is working against, rather than for, the user.</p>
</blockquote>
<p>或许大多初次接触Gentoo的人都会被它的哲学思想所吸引。
Linux爱好者使用Linux而非Windows、MacOS，大概很大程度上是为了“掌控自己的电脑”，而不是让电脑掌控自己。
类似的，我们使用FOSS，也很大程度上是为了“<strong>掌控自己的软件</strong>”。</p>
<p>但事实上，在大多数系统上，我们只能<strong>选择我们的软件</strong>。
因为大多数发行版的包管理程序提供的是<strong>二进制文件</strong>，这让我们难以对软件本体进行定制。
这样的坏处是，为了使得软件可以供大多数用户使用，这些发行版提供的软件包可能包含很多对个体用户来说<strong>冗余的功能</strong>。
比如一个提供图形界面的软件可能同时带有GNOME和KDE支持，而用户可能甚至不使用桌面环境。
再比如大多数发行版的自带内核很可能有非常多<strong>冗余的硬件驱动</strong>。</p>
<p>Gentoo<strong>基于源代码的软件包管理方式</strong>使得用户天然的可以对软件本身进行高度定制。
当然，最高度的定制应当是自己下载源代码并自己编译，但这样未免非常麻烦，而且需要对相应的源代码有一定的了解。
Gentoo则通过包管理程序<strong>portage</strong>和<strong>USE flags</strong>提供了高度<strong>自动化、全局化</strong>的软件定制方法。
这使得我们可以更自由也更方便地掌控我们的软件：
想要完全抛弃X，改用Wayland？只需要在<code>make.conf</code>中的设置全局USE flag <code>USE=&quot;-X wayland&quot;</code>；
想要针对自己的显卡对所有软件进行优化？只需要设置显卡选项<code>VIDEO_CARDS=nvidia</code>……</p>
<p>Gentoo的哲学<strong>并非让用户感到困难</strong>，而是尽可能<strong>让用户感到舒适</strong>。
也就是，在提供尽可能多的定制空间的同时，保证这些定制的便捷。</p>
<p>当然实际使用Gentoo后，才会发现Gentoo的包管理和各种特有的配置方式具有<strong>较陡的学习曲线</strong>。
这就是一个Linux语境下常见的trade-off，其实学习使用Gentoo和学习使用vim、make、shell scripting等是同一个道理，都是<strong>用短时间较多的精力得到长时间更舒适的体验</strong>。</p>
<h3>洁癖福音</h3>
<p>很多深入了解过Linux的人会走到这样一个阶段：
突然听说或意识到systemd、GNOME、glibc等这些常用的东西非常<strong>臃肿</strong>，于是竭力想要避开这些所谓臃肿的东西。
于是这些人（比如说我）就会开始使用各种Window manager来替代庞大的桌面环境，
寻找不用systemd作为init system的发行版（比如artix、void等），尝试用musl替代glibc，用busybox替代GNU coreutils……</p>
<p>伴随着对臃肿的排斥，还有<strong>对免费开源软件的高度推崇</strong>和对收费专利软件的极端厌恶。</p>
<p>这样的阶段，我愿称之为<strong>软件洁癖</strong>。
虽然现在我佛了很多，但或多或少还保留着这样的洁癖。
而Gentoo一定会是软件洁癖患者的福音。</p>
<p>从安装阶段开始，Gentoo就允许用户指定<strong>profile</strong>。
如果不想要庞大的桌面环境，选择不带有GNOME或KDE的profile就行。
如果不想要systemd，选择不带有systemd的profile就行。
不想要glibc，选择不带有glibc的profile就行……
即使安装完成，用户也可以随时切换profile，切换后只需要一次全面系统更新就可以。</p>
<p>Gentoo坚持<strong>无必要，不自带</strong>的原则，将大多数的选择权给到了用户。
比较典型的例子是，Gentoo是不自带<code>sudo</code>的。
Gentoo贴心地考虑了觉得<code>sudo</code>也实在臃肿，必须要用<code>doas</code>的人（比如我）。</p>
<p>Gentoo的包管理机制也可以让洁癖<strong>非常省心</strong>。
不想要什么东西，直接在全局USE flag里禁用它就好了。
只想用开源证书的软件包，直接在<code>package.license</code>里指定就好了。</p>
<h3>中庸之道</h3>
<p>Gentoo把大多数选择权交给用户，所以提供了很多的选择。
某些<strong>极端的</strong>发行版会把一些“好东西” <strong>强行塞给用户</strong>，这反而让用户失去了选择权。
比如Alpine Linux、GNU guix等都是这类。
Gentoo从来不是极端的，而是<strong>中庸的</strong>。
也就是说，Gentoo即能满足传统用户需求，也能满足各种洁癖患者的需求。</p>
<p>Gentoo会告诉你<strong>OpenRC</strong>是个很好用很轻量的init system，但它也允许你使用systemd。
Gentoo会推荐你定制自己的内核来充分开发电脑性能，但它也允许你使用kernel-bin来<strong>节省时间</strong>和保持更新。</p>
<h3>虽不能至，心向往之</h3>
<p>无可非议的一点是，Gentoo的安装和使用的确比“正常的”发行版要困难许多。
然而对于很多Linux爱好者，我们并不害怕困难，我们甚至<strong>乐于迎接调整，突破困难</strong>。</p>
<p>刚认识到vim的时候，我感觉这个小小的编辑器简直颠覆我的世界观。
我知道学习它肯定会<strong>要花费很多精力</strong>，但我也知道学会了它能为我带来巨大的<strong>效率提升</strong>（<s>还能装逼</s>）。
于是我尝试去学习它的基本概念，并通过实践和解决实践中遇到的问题不断积累经验，最终基本掌握了它。</p>
<p>这样的<strong>学习和解决问题的过程</strong>让我感到<strong>由衷的快乐</strong>。</p>
<p>Gentoo对我来说也是这样的存在，它是很大的挑战，所以也是很大的<strong>快乐源泉</strong>（<s>怎么听起来这么像m</s>）。</p>
<p>另一方面，正是因为Gentoo对于一个newbie来说如此“高深莫测”，所以会激起ta强烈的<strong>好奇心以及敬畏感</strong>。
这样的好奇心让我愿意去探索Gentoo这座大山，感叹它的奇崛，享受<strong>登高望远</strong>。
这样的敬畏心又让我深知自己能力之渺小，让我在这座大山乃至更多更高的大山下<strong>保持谦卑</strong>。</p>
<p>总之，Gentoo努力<strong>让用户得到最舒服的体验</strong>，这样的<strong>哲学宗旨</strong>让它成为了<strong>洁癖的福音</strong>，
也让无数日用过它、安装过它、了解过它、听说过它的人<strong>心向往之</strong>。</p>

    ]]>
      </content>
    </entry>
  
    
    <entry>
      <title>NixOS 治好了我的发行版跳跃症</title>
      <link href="https://eden.is-a.dev/posts/nixos/"/>
      <updated>2025-01-05T00:00:00+00:00</updated>
      <id>https://eden.is-a.dev/posts/nixos/</id>
      <content type="html">
        <![CDATA[
      <blockquote>
<p>自从我开始用 Linux，就一直在 distro hopping。
我用过不下 <strong>20</strong> 个 Linux 发行版，其中大多数都是实装并日用过的。
<strong>NixOS</strong> 治好了我的发行版跳跃症，让我连想 distro hop 的心思都没有了。
因为 NixOS 实在太完美了……</p>
</blockquote>
<!-- more -->
<h2>为什么要安装 NixOS</h2>
<p>我用过不下 <strong>20</strong> 个 Linux 发行版，其中大多数都是实装并日用过的。
在最爱折腾的那个时期，我会每隔<strong>几周甚至几天</strong>就换一个发行版，不厌其烦地在各种发行版里复刻自己的配置。
曾经我下定决心，要找到一个非常让我满意的发行版，从此不再 distro hop。
Artix、Void、Fedora 都几乎做到了这点，但最多也就持续了一年不到。</p>
<p>我喜欢通过不断地 distro hop 来体验各种迥异的发行版，发掘它们的内在共性和各自的特色，
但我会更愿意日用某些特定类型的 distro。
现在看来，能让我日用地比较舒服的 distro 需要满足以下条件：</p>
<ol>
<li>
<p>足够 <strong>bleeding edge</strong>：作为一个 professional beta tester，我需要一个能够让我及时获取最新软件包的 distro。
显然 Arch-based distros、Void、Fedora 在这点上都够格，尤其是 Fedora Rawhide。</p>
</li>
<li>
<p>足够 <strong>stable</strong>：当然谁都不希望自己的系统时不时出问题。这一点好像和 bleeding edge 有点冲突，比如 Arch 系大多不够 stable。
所以我在 roll 失败多次后放弃了 Arch，选择了更稳定的 Void 和 Fedora。</p>
</li>
<li>
<p>足够 <strong>vanilla</strong>：也就是说自带的东西不能太多，因为我喜欢自己折腾，不需要你给我都安排好。
一开始探索的时候会更喜欢 Zorin、Garuda、Archcraft 等这种<s>花里胡哨</s>开箱即用的 distro。
后来逐渐形成了自己的配置体系了，就什么都想自己干了。
显然一直在说的这三款在这方面都做得不错。</p>
</li>
</ol>
<p>那么目前看来，Void 和 Fedora 完全可以满足我的日用需求，为什么我还要换成 NixOS 呢？</p>
<p><strong>因为我无聊了。</strong>
上大学后，用来折腾 Linux 的时间少了很多。
曾经我可以花一整天时间浪费在折腾系统配置上，而随着探索的深入，我越来越接近理想的配置，
也越来越被已有的配置固化，于是越来越少的有折腾的欲望。</p>
<p>直到有一天，在我的 Fedora Rawhide（<s>不是，真的有人日用 Fedora Rawhide 啊</s>）更新了一个 GNOME 版本后，
出现了很多莫名其妙的 bug。And I was like,
&quot;You know what, <em>I'm done. I'm gonna try <strong>NixOS</strong>.</em>&quot;</p>
<p>为什么是 NixOS？因为我馋了。时不时在 Unixporn 等地方看到 NixOS 用户，感觉 NixOS 是不是已经准备取代 Arch 的 <strong>btw</strong> 地位了。
就像 Gentoo 一样，NixOS 有点被<strong>神化</strong>了，这两个东西对我来说曾是遥不可及的两座大山。
成功<a href="https://eden.is-a.dev/posts/Why-gentoo-so-popular">日用 Gentoo</a> 后，我克服了对这些被神化的东西的畏惧。
当年第一次接触 NixOS 的时候，我都不知道怎么安装它。
现在可好了，现在 NixOS 都用上 Calamares Installer 了，安装起来比 Arch 都简单。</p>
<p>我有一种预感，NixOS 会重新激发我折腾系统的热情，事实证明这个预感是对的。</p>
<div style="text-align:center;">
<p><img src="/images/btw-i-use-nixos.png" alt="btw I use NixOS"></p>
</div>
<p><em>图源：<a href="https://www.reddit.com/r/NixOS/comments/1dpc0ea/title">https://www.reddit.com/r/NixOS/comments/1dpc0ea/title</a></em></p>
<h2>NixOS 到底好在哪</h2>
<p>到现在为止，我竟然已经用了<strong>一年多</strong>的 NixOS 了。
而且现在我完全没有尝试别的发行版的欲望。因为 NixOS 已经可以满足我的几乎所有需求了。</p>
<p>首先，显然 NixOS 满足了我上面提到的三个日用需求。
要 <strong>bleeding edge</strong> 是吧，那就用 <code>nixpkgs-unstable</code> 吧，这玩意在某些层面上比 Fedora Rawhide 还狠。
要 <strong>stable</strong> 是吧，bro，在 NixOS 上你随时可以安装一个最新版本的软件，让它和旧版本共存，体验完觉得不舒服直接删掉就行。
<strong>vanilla</strong> 就更不用说了，NixOS 的 base system 基本上啥都没有，which means everything can be customized as you like.</p>
<p>那么接下来再让我细说一些 NixOS 的独特的好处。</p>
<h3>无敌的重构</h3>
<p>In case you don't know, NixOS 的一切系统配置都使用 <strong>Nix 语言</strong>写的<strong>配置文件</strong>来描述的。
只要你用同样的配置文件，就可以重构出一模一样的系统。
现在还是 <strong>flakes</strong> 的时代，有 lock 机制，完全可以保证系统的一比一重构。
所以如果要装新系统，或者重装系统，要保留系统配置的话留一个配置文件就行了。
拿着配置文件，运行一行命令，马上就可以重构出一个一模一样的系统。</p>
<p>每一次“系统更新”都是一次基于新的配置文件的重构，而不是一次“升级”。
新构建出来的整个系统与旧的整个系统是<strong>完全独立</strong>的，所以随时可以<strong>回滚</strong>到旧的系统。
This is true <strong>atomic upgrade</strong>.</p>
<p>哦我们还有 <a href="https://github.com/nix-community/home-manager"><strong>home-manager</strong></a>，可以用 Nix 来管理你的 home 目录，这样你的 home 目录也可以随时重构。
这样就不用折腾什么 dotfile manager 了，
一个文件，一行命令，开箱即用，极其省心。</p>
<h3>明明很简单</h3>
<p>有人说，啊，NixOS 太难了，学不会，配置一个系统还得学一门语言。
我说，那你用别的系统不也得用 shell 命令配置吗？</p>
<p>一开始我也感觉 NixOS 很难，但用了没多久就会发现，NixOS 是把大多数问题变得太<strong>简单</strong>了。
比如说，我想在别的系统里用 fcitx5 来输入中文，我得先装 fcitx5 这个软件包，然后装一些 fcitx5 插件，然后配置一些环境变量。
这好麻烦，每次换系统都得重新配置一遍，记不住环境变量每次都得查。
而 NixOS 里呢，我只需要在配置文件里写：</p>
<pre class="language-nix"><code class="language-nix">i18n<span class="token punctuation">.</span>inputMethod <span class="token operator">=</span> <span class="token punctuation">{</span><br>  enable <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span><br>  type <span class="token operator">=</span> <span class="token string">"fcitx5"</span><span class="token punctuation">;</span><br>  fcitx5<span class="token punctuation">.</span>addons <span class="token operator">=</span> <span class="token keyword">with</span> pkgs<span class="token punctuation">;</span> <span class="token punctuation">[</span><br>    fcitx5<span class="token operator">-</span>chinese<span class="token operator">-</span>addons<br>  <span class="token punctuation">]</span><span class="token punctuation">;</span><br>  fcitx5<span class="token punctuation">.</span>waylandFrontend <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre>
<p>非常的简单明了，看一眼就知道在做什么。不需要你去担心环境变量什么的，NixOS 都会帮你配置好。
这就是<strong>声明式配置</strong>的好处。</p>
<p>配置 Void 的时候，缺少自带的音频服务，得自己装。每次都被 alsa、pulseaudio、pipewire 搞得头大。
NixOS 里，我只需要写 <code>services.pipewire.enable = true;</code> 就好了。</p>
<p>这些 options 如此方便，因为定义这些 options 的人已经帮你把背后的复杂配置都处理好了。
要装什么软件包，有什么依赖，配置什么 systemd 服务，定义什么环境变量，很多时候这些都<strong>不需要你来纠结</strong>。</p>
<p>至于 Nix 语言，作为声明式、函数式语言，它的<strong>自解释性</strong>很强，很容易看懂，不需要学也能轻松上手。
至于一些更高级用法，也可以慢慢学，把握它的各种特性，可以写出更优雅的配置。</p>
<h3>大</h3>
<p>NixOS 太<strong>大</strong>了。
这里是指很多个层面。</p>
<p>比如说 <a href="https://github.com/NixOS/nixpkgs"><strong>nixpkgs</strong></a>，作为 NixOS 的软件仓库，它的软件包数量是其他任何软件仓库难以比拟的。
见下图，完全是遥遥领先。</p>
<div style="text-align:center;">
<p><img src="/images/repology-graph.png" alt="repology graph"></p>
</div>
<p><em>图源：<a href="https://repology.org/repositories/graphs">https://repology.org/repositories/graphs</a></em></p>
<p>再比如说，<strong>NixOS 社区</strong>。
NixOS 社区的活跃程度和体量完全不亚于 Arch。
我目前为止碰到的几乎所有问题，基本都可以在 <a href="https://discourse.nixos.org"><strong>NixOS Discourse</strong></a> 上找到答案。
nixpkgs 的维护者们也是非常活跃的，否则哪来的这么多软件包和这么多有用的 options。</p>
<p>还有，<strong>NixOS 的生态</strong>。
一旦染上了 NixOS，<s>这辈子就有了</s>你很可能会想用 Nix 来 <strong>declare everything</strong>。
Luckily，Nix 提供了很多工具来帮你实现这个愿望。
你可以用 home-manager 声明你的 home 目录，可以用 <a href="https://github.com/nix-community/nixvim">nixvim</a> 声明你的 neovim 配置，
你可以用 nix shell 来管理开发环境……</p>
<h2>为什么不应该用 NixOS</h2>
<p>NixOS 太好了，NixOS 无敌了，都有 NixOS 了，其他系统还有存在的必要吗？为什么不能让所有人都用 NixOS？
我的脑子曾经想过这些问题，但其实还是有很多不应该用 NixOS 的理由。</p>
<p>NixOS 的<strong>学习曲线比较陡</strong>。
学习使用 NixOS、Nix 语言等给我的感受和学习 Vim 差不多，就是一开始感觉好难，后面悟到精髓以后就越学越起劲。
和学 Vim 的感受类似，<strong>用了 NixOS 后的唯一后悔的是没有早点开始用 NixOS</strong>。
但是，其实还是得有一个铺垫的过程，才能更好地上手和理解 NixOS。
如果你刚开始用 Linux，或许不应该马上尝试 NixOS。
你得先用别的 distro 学会 Linux 的基本逻辑才能用 NixOS 用得得心应手。
而且有一说一，配置 NixOS，把已有的配置迁移到 home-manager 等很多事情是很花时间的，说白了就是你得愿意花时间和精力去折腾。
如果你只是想用系统工作、浏览网络、打游戏什么的，NixOS 对你可能也没什么用，反而会浪费你的时间</p>
<p>NixOS <strong>不是 FHS 兼容</strong>的。也就是说，NixOS 的根目录结构和正常的 distro 很不一样，很多正常 distro 上能跑的命令，能运行的程序
在 NixOS 上可能就不能用了。
当然 NixOS 提供了很多应对这些问题的方法，比如 nix shell、buildFHSEnv 等。
你得意识到 NixOS 和正常的 distro 是很不一样的，要有心理准备这些问题可能出现，出现后要<strong>积极尝试解决</strong>。
比如我想创建一个 wayland session，但 NixOS 根本没有 <code>/usr/share</code>，就得上网查解决方法，
当然这种基础问题的解决方法一般都能在 NixOS Discourse 上找到。
有些时候实在没办法，或解决办法太麻烦的时候，我就会用 <a href="https://distrobox.it"><strong>distrobox</strong></a>。
distrobox 太好了，我直接在容器里跑一个 Fedora，很多问题就解决了。</p>
<p>还有一些很被诟病的问题，比如 NixOS 的文档超级烂，Nix 重构的输出相当难读，NixOS 用着用着磁盘就满了等等。
还是那句话，社区的力量是伟大的，很多问题问社区基本就可以解决了（<s>但是文档是真的很烂</s>）。
比如 <a href="https://github.com/viperML/nh">nh</a> 就提供了更易读的重构输出以及简单的磁盘清理方法。
你得相信你遇到的问题，很多人都遇到过，而且很可能已经被解决了。
实在不行你自己去问就行了，社区里的人都很热心。</p>
<p>对于我来说，瑕不掩瑜，NixOS 的优点远远大于缺点，而且很多不足之处都有弥补方式，所以我很满足于 NixOS。</p>

    ]]>
      </content>
    </entry>
  
</feed>